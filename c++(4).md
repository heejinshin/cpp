# 객체지향 프로그래밍

참고: https://jeong-pro.tistory.com/95

프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간 유기적인 상호작용을 통한 로직을 구성하는 프로그래밍 방법. 

- 장점: 
  - 코드 재사용이 용이하다. 이미 만들어진 클래스를 가져다 쓸 수 있고 상속을 통해 확장해서 사용할 수 있다.
  - 유지보수가 쉽다. 해당 클래스 내부의 멤버변수 또는 메서드를 수정하여 사용한다.

## 클래스 

속성과 행위를 변수와 메서드로 정의한것

## 인스턴스(객체)

클래스에서 정의한 것을 토대로 실제 프로그램에 사용되는 데이터

## 객체 지향프로그래밍에서 추상화

공통의 속성이나 기능을 묶어 이름을 붙이는 것

## 상속

- 왜 쓰게 되었나? 남이 짜놓은 코드, 라이브러리를 통해서 소스를 가져와 사용하다 보면 버전에 따라 동작하지 않을 수도 있고 불필요한 코드의 수정작업을 해야하는 경우가 있다. 이 문제를 해결하기 위해 상속의 개념이 도입되었다.

- 상속은 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정하여 사용할 수 있게하는 것이다. 

  | 다형성이란, 하나의 변수명 또는 함수명이 상황에 따라 다른 의미로 해석될 수 있다는 것이다. 오버라이딩과 오버로딩이 가능하다는 개념.

  - 오버라이딩: 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것

- 오버로딩: 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것. 

## 생성자

- 객체를 생성할 때 맨 처음 실행되는 메서드, 멤버변수를 초기화 시킨다. 
- 리턴값이 없다.

## 기본 생성자

매개변수를 갖지 않거나 모두 기본값이 설정된 매개 변수를 가지고 있는 생성자.

클래스를 인스턴스화할 때 사용자가 초기값을 제공하지 않으면 기본 생성자가 호출된다. 

## 정적 메소드

참고: http://tcpschool.com/cpp/cpp_encapsulation_staticConst

c++에서는 클래스의 멤버 함수도 정적으로 선언할 수 있다. 

~~~ 
1. 객체이름.멤버함수이름()  //일반 멤버함수의 호출
2. 클래스이름. 멤버함수이름()	//정적 멤버함수의 호출
~~~

- 해당 클래스의 객체를 생성하지 않고, 클래스 이름만으로 호출이 가능하다.

- 객체를 생성하지 않으므로, this 포인터를 가지지 않는다.

- 특정 객체와 결합하지 않으므로, 정적 멤버 변수밖에 사용할 수 없다. 

  ~~~ c++
  class person
  {
  private:
  	string name_;
  	int age_;
  poublic:
  	static int person_count_;				//정적 멤버변수 선언
  	static int person_count();			//정적 멤버함수 선언
  	Person(const string&name, int age); 		//생성자
  	~person(){person_count_--;}						//소멸자
  	void ShowPersonInfo();
  };
  int Person::person_count_=0;			//정적 멤버 변수의 정의 및 초기화
  ...
  int Person::person_count()			//정적 멤버 함수의 정의
  {
  	return person_count_;
  }
  ~~~

  ---

  ### 상수 멤버변수

  한 번 초기화 하면 그 값을 변경할 수 없는 멤버 변수

  ~~~ 
  const 타입 멤버변수이름;
  ~~~

  클래스 전체에 걸쳐 사용되는 중요한 상수는 상수 멤버 변수로 정의하여 사용하는 것이 좋다. 



		### 	소멸자

​		c++에서 생성자는 객체 멤버의 초기화 뿐 아니라, 객체를 사용하기 위한 외부 환경까지도 초기화 하		는 역할을 한다. 따라서 객체의 수명이 끝나면 생성자의 반대역할을 수행할 멤버 함수도 필요해 지는		데, 이 역할을 하는 멤버 함수를 소멸자라고 한다. 

​		객체의 수명이 끝나면 컴파일러에 의해 자동으로 호출되며, 사용이 끝난 객체를 정리해 준다. 

		### 	